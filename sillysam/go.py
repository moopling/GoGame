import pdb

import os, sys
import pygame
from pygame.locals import *
from weakref import WeakKeyDictionary

if not pygame.font: print 'Warning, fonts disabled'
if not pygame.mixer: print 'Warning, sound disabled'

# CONSTANTS ---------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

BOARDER_SIZE = 0
SQUARE_SIZE = 50
GAME_SIZE = 9

BOARD_COLOUR = (255,219,112)

# UTILITIES ---------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

def Debug(msg):
    print msg
    
def load_image(name, colorkey=None, subdir='data', size=SQUARE_SIZE):
    """loads an image, converts it and resizes it, then sets 
    transparency = colourkey
    """
    fullname = os.path.join(subdir, name)
    try:
        image = pygame.image.load(fullname)
    except pygame.error, message:
        print 'Cannot load image:', name
        raise SystemExit, message
    image = pygame.transform.smoothscale(image.convert(), (size,size))
    if colorkey is not None:
        if colorkey is 'auto':
            colorkey = image.get_at((0,0))
        image.set_colorkey(colorkey, RLEACCEL)
    return image

class EventManager:
    """this object is responsible for coordinating most communication
    between the Model, View, and Controller.
    """
    def __init__(self):
        self.listeners = WeakKeyDictionary()
        self.eventQueue = []
        
    def RegisterListener(self, listener):
        self.listeners[listener] = True

    def UnregisterListener(self, listener):
        if listener in self.listeners.keys():
            del self.listeners[listener]
        
    def Post(self, event):
        """Post a new event.  It will be broadcast to all listeners"""
        if not isinstance(event, TickEvent):
            Debug("     Message: " + event.name)
        for listener in self.listeners.keys():
            listener.Notify(event)
            
class ManagedEvent:
    """this object has behaviour which should be default for any class
    which suscribes to an event manager,
    """
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)

    
# EVENTS ------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------
        
class Event:
    """this is a superclass for any events that might be generated by an
    object and sent to the EventManager
    """
    def __init__(self):
        self.name = "Generic Event"
        
class TickEvent(Event):
    def __init__(self):
        self.name = "CPU Tick Event"

class QuitEvent(Event):
    def __init__(self):
        self.name = "Quit Event"
        
class MouseClickEvent(Event):
    def __init__(self, coord):
        self.name = "Mouse Click Event"
        self.coord = coord

class MapBuiltEvent(Event):
    def __init__(self, map):
        self.name = "Map Built Event"
        self.map = map
    
class PointBuiltEvent(Event):
    def __init__(self, point):
        self.name = "Point Built Event"
        self.point = point
        
class Request(Event):
    """the same as a event. I figured I might eventually split functionality between requests and events.
    The events are notifications that something has happened where requests are ... 
    """
    def __init__(self):
        self.name = "Generic Request"

class MapBuildRequest(Request):
    def __init__(self):
        self.name = "Map Build Request"
        
class PlayerMoveRequest(Request):
    def __init__(self, point, colour):
        self.name = "Player Move Request"
        self.colour = colour
        self.point = point
        
class PlayerMovedEvent(Event):
    def __init__(self, score):
        self.name = "Player Move Event"
        self.score = score
        
# CONTROLLERS -------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

class Controller:
    """this is a superclass for any controller that might be generated. 
    It ensures automatic registrations to the event manager.
    """
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)

class InputController(Controller):
    """every tick event this controller is checked to see if an input has
    been stored on the pygame.event stack and respondes apprioptiatly
    by creating an event
    """
    def Notify(self, event):
        if isinstance(event, TickEvent):
            for event in pygame.event.get():
                newEvent = None
                
                if event.type == pygame.QUIT:
                    newEvent = QuitEvent()
                
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    newEvent = MouseClickEvent(pygame.mouse.get_pos())
                
                if newEvent:
                    self.eventManager.Post(newEvent)

class ClockController(Controller):
    """effectivly the main loop
    """
    def Start(self):
        self.keepGoing = True
        while self.keepGoing:
            event = TickEvent()
            self.eventManager.Post(event)
            
    def Notify(self, event):
        if isinstance(event, QuitEvent):
            self.keepGoing = False

            
# GAME --------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

class GoGame:
    
    STATE_PREPARING = 'Preparing'
    STATE_RUNNING =  'Running'
    STATE_PAUSED = 'Paused'
    
    def __init__(self, eventManager, gameSize, Komi=0, goesFirst='black'):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        self.state = GoGame.STATE_PREPARING
        self.size = gameSize
        
        self.players =  [Player(eventManager, colour="black"),Player(eventManager, colour="white", startScore=Komi)] # A list with the white/black players
        
        if 'black' == goesFirst:
            self.currentPlayer = self.players[0]
        elif 'white' == goesFirst:
            self.currentPlayer = self.players[1]
        else:
            raise Error
        
        self.map = Map(eventManager, self.size)
        
    def SwitchPlayers(self):
        for player in self.players:
            if player != self.currentPlayer:
                self.currentPlayer = player
                break
    
    def Start(self):
        self.map.Build(self.size)
        self.state = GoGame.STATE_RUNNING
        
    def Notify(self, event):
        if isinstance(event, TickEvent):
            if self.state == GoGame.STATE_PREPARING:
                self.Start()
        
        elif isinstance(event, PlayerMovedEvent):
            self.currentPlayer.score += event.score
            print str(self.currentPlayer.colour) + " : " + str(self.currentPlayer.score)
            self.SwitchPlayers()
        
        elif isinstance(event, MouseClickEvent):
            closestPoint = self.map.findNearestPoint(event.coord)
            self.eventManager.Post(PlayerMoveRequest(closestPoint, self.currentPlayer.colour))

            
class Map:
    
    STATE_PREPARING = False
    STATE_BUILT = True

    def __init__(self, eventManager, size):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        self.state = Map.STATE_PREPARING
        
        self.previousStates = set()
        
        self.points = []
        self.size = None
        
        self.rules = Rules()
        
    def Build(self, size):
        
        self.size = size
        rows = columns = range(self.size)
        
        #indexing from topleft corner
        for x in rows:
            if x == max(rows):    
                position1 = 'Right'
                
            elif x == min(rows):    
                position1 = 'Left'

            else:
                position1 = ''
        
            for y in columns:
        
                if y == max(columns):
                    position2 = 'Bottom'
            
                elif y == min(columns):          
                    position2 = 'Top'
                
                else:          
                    position2 = ''
                    
                position = position2 + position1    
                newPoint = Point(self.eventManager, (x,y), position)
                #for every x,y posistion a new 'Point' is intialised, and is passed if it is an edge/corner/midboard and if so which.
                #i.e. 'TopRight' is the topright corner, 'Top' would be the top edge and '' would be any midboard position
                self.points.append(newPoint) #saves the point into a list of points
        

        for point in self.points:
            for direction in point.neighbors:
                point.neighbors[direction]= self.getPoint(point.coord, direction)
                

        self.state = Map.STATE_BUILT
        
        self.eventManager.Post(MapBuiltEvent(self))
        
    def getPoint(self, coord, direction=None):
        """this function allows you to ask the board for a spesific point
        or a spesific points neighbor
        """
        if direction == 'up':
            coord = (coord[0],coord[1]-1)
        elif direction == 'down':
            coord = (coord[0],coord[1]+1)
        elif direction == 'right':
            coord = (coord[0]+1,coord[1])
        elif direction == 'left':
            coord = (coord[0]-1,coord[1])
        
        for point in self.points:
            if point.coord == coord:
                return point
        raise Error

    def findNearestPoint(self, coord):
        pointDistance = []
        for point in self.points:
            RMS = 0
            for n in range(2):

                RMS += abs(coord[n]-point.graphics.coord[n])    #for every point takes the dinstance from the x and y coordinate given and stores the sum.
                
                
            pointDistance.append(RMS) #because of symitery in the grid the RMS values will be ranked in the correct order

        closestPoint = self.points[pointDistance.index(min(pointDistance))]
        return closestPoint
    
    def Notify(self, event):
        if isinstance(event, MapBuildRequest):
            if not self.state:
                self.Build()
            
        elif isinstance(event, PlayerMoveRequest):
            #updates the gamestate. Applies the rules to see if a move has been made.
            hasChanged, score = self.rules.applyRules(self.points, event.point, event.colour, self.previousStates)
            if hasChanged:
                self.eventManager.Post(PlayerMovedEvent(score))
            
class Rules:
    def __init__(self):
        self.previousStates = []
        
    def hasLiberties(self, point):
        for neighbor in point.neighbors.values():
            if neighbor.state == None:
                return True
        
        return False
    
    def getFriendlyNeighbors(self, point):
        friendlyNeighbors = set()
        for neighbor in point.neighbors.values():
            if point.state == neighbor.state:
                friendlyNeighbors.add(neighbor)
        
        return friendlyNeighbors
    
    def getEnemyNeighbors(self, point):
        EnemyNeighbors = set()
        for neighbor in point.neighbors.values():
            if (point.state != neighbor.state) and (neighbor.state != None):
                EnemyNeighbors.add(neighbor)
        
        return EnemyNeighbors
        
    def isAlive(self, currentPoint, points, group):
        #returns a bool to indicate if it is alive or not plus as set of the group in question)
        group.add(currentPoint)
        
        if self.hasLiberties(currentPoint):
            return True, group
        else:
            uniqueNeighbors =self.getFriendlyNeighbors(currentPoint).difference(group)
            for neighbor in uniqueNeighbors:

                definitelyAlive, group = self.isAlive(neighbor, points, group)
                if definitelyAlive:
                    return True, group
            
            return False, group
    
    def getEnemy(self, state):
        if state == 'white':
            return 'black'
        elif state == 'black':
            return 'white'
        else:
            return None
    
    def Kills(self, currentPoint, points):
        killgroup = set()
        for neighbor in self.getEnemyNeighbors(currentPoint):
            alive, group = self.isAlive(neighbor, points, set())
            if not alive:
                killgroup = killgroup.union(group)
        """looks at the neighbors of the stone in question, if a neighbor is of the opposite colour checks if it is alive if a move is played in the current square.
        if the neighbors are dead it add it to a set called 'killgroup' which are marked to be removed.
        """
        
        score = 0
        if len(killgroup)>0:
            for deadpoint in killgroup:
                for point in points:
                    if deadpoint == point:  
                        point.state = None  #for each stone in the killgroup remove it and add a point to the current player
                        score += 1
           
        gameState = []
        for point in points:
            gameState.append(point.state)
        
        if len(killgroup)==0:
            self.previousStates.append(gameState) #if the state did not already exist mark it as existing.
            return False, 0  
            
        if gameState in self.previousStates:
            oldState = self.getEnemy(currentPoint.state)
            currentPoint.state = None
            for deadpoint in killgroup:
                for point in points:
                    if deadpoint == point:
                        point.state = oldState
            return False, 0 #A badly implimented co rule                
            
        else:
            self.previousStates.append(gameState) #if the state did not already exist mark it as existing.
            return True, score
       
    
    def isEmpty(self, point):
        if point.state == None:
            return True
        else:
            return False
    
    def applyRules(self, points, playPoint, colour, previousStates):
        """returns bool indicating if there has been a change to the 
        board + an int for the score
        """
        
        if self.isEmpty(playPoint): 
            playPoint.state = colour #if the point is empty it plays the move and then checks to see if it breaks any rules 
        else:
            return False, 0
   
        killedSomething, score = self.Kills(playPoint, points) #checks if anything has been killed
        
        if killedSomething:
            return True, score #if it has the move is legal
        
        stillAlive, score = self.isAlive(playPoint, points, set()) #else checks if the stones are alive anyway
        
        if stillAlive:
            return True, 0 #returns
            
        else:
            playPoint.state = None #undoes the move and returns
            return False, 0
            
                
class Point:
    def __init__(self, eventManager, coord, position):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        self.state = None
        
        self.coord = coord
        self.position = position
        self.neighbors = {}
        
        if 'Top' not in position:
            self.neighbors['up'] = None
        
        if 'Bottom' not in position:
            self.neighbors['down'] = None
        
        if 'Left' not in position:
            self.neighbors['left'] = None
        
        if 'Right' not in position:
            self.neighbors['right'] = None
        
        #Make Graphics for Point
        #creates the corresponding PieceSprite and BoardSprite
        self.eventManager.Post(PointBuiltEvent(self))
        
    def saveGraphics(self, graphics):
        self.graphics = graphics
    
    def Notify(self, event):
        if isinstance(event, PlayerMovedEvent):
            self.graphics.state = self.state
                
class Player:
    def __init__(self, eventManager, colour, startScore=0):
        self.colour = colour
        self.score = startScore
        
    def __str__(self):
        return "Player: " + self.colour

# VIEW --------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

class BoardSprite(pygame.sprite.Sprite):
    def __init__(self, point, group=None):
        """creates a board square for every coordinate. The posistion of the point it is linked to
        spesifies the image that should be used
        """
        pygame.sprite.Sprite.__init__(self, group)
        
        self.point = point

        X, Y = self.point.coord
        filename = self.point.position+'Picture.png'
        self.image = load_image(filename, colorkey='auto', size=SQUARE_SIZE)
        self.rect = self.image.get_rect()
        self.rect.topleft = (X*SQUARE_SIZE+BOARDER_SIZE/2, Y*SQUARE_SIZE+BOARDER_SIZE/2)

class PieceSprite(pygame.sprite.Sprite):
    def __init__(self, point, group=None):
        """loads 3 images and saves them to be rotated upon the change in state
        of the point it is linked to. Updates the image whenever a move is played.
        """
        
        pygame.sprite.Sprite.__init__(self, group)
        
        self.state = None
        
        self.point = point
        self.point.saveGraphics(self)
        X, Y = self.point.coord
        
        self.whiteimage = load_image('whitepiece.png', colorkey='auto', size=SQUARE_SIZE)
        self.blackimage = load_image('blackpiece.png', colorkey='auto', size=SQUARE_SIZE)
        self.noimage = load_image('nopiece.png', colorkey='auto', size=SQUARE_SIZE)
        
        self.rect = self.noimage.get_rect()
        self.coord = ((X+0.5)*SQUARE_SIZE+BOARDER_SIZE/2, (Y+0.5)*SQUARE_SIZE+BOARDER_SIZE/2)
        self.rect.center = self.coord
        
        self.update()
        
    def setState(self, state):
        self.state = state
    
    def update(self):
        if self.state =='white':
            self.image = self.whiteimage
            
        elif self.state == 'black':
            self.image = self.blackimage

        else:
            self.image = self.noimage

class PygameView:
    def __init__(self, eventManager, boardSize):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        pygame.init()
        
        windowSize = BOARDER_SIZE+SQUARE_SIZE*boardSize
        
        self.window = pygame.display.set_mode((windowSize,windowSize)) #creates a window based on the size of the game
        pygame.display.set_caption('My Go Game')
        
        self.background = pygame.Surface(self.window.get_size()) #fills the window with the game surface
        self.background.fill(BOARD_COLOUR)
        
        self.boardSprites = pygame.sprite.RenderUpdates() #creates a render group. All sprites are saved in this group and can be refreshed by updating the group
        self.pieceSprites = pygame.sprite.RenderUpdates()
        
    def Notify(self, event):
        if isinstance(event, TickEvent):
            self.boardSprites.clear(self.window, self.background) #every tick, clear the groups.
            self.pieceSprites.clear(self.window, self.background) #both to display the background colour and get rid of any removed pieces
            
            self.boardSprites.update() #update the groups. Refreshing every item in the group
            self.pieceSprites.update()
            
            dirtyRects1 = self.boardSprites.draw(self.window) # create a rectangle over any sprites which have changed.
            dirtyRects2 = self.pieceSprites.draw(self.window)
            
            dirtyRects = dirtyRects1 + dirtyRects2 # order is important, they will be refreshed in order.
            
            pygame.display.update(dirtyRects) #refreshes the screen
            
        elif isinstance(event, MapBuiltEvent):
            pass
            
        elif isinstance(event, PointBuiltEvent):
            BoardSprite(event.point, self.boardSprites) #everytime a point is built a corresponding board graphics is made for it
            PieceSprite(event.point, self.pieceSprites) #and piece graphics too!


# MAIN --------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------              
    
def main():
    eventManager = EventManager()
    #initialises the view, model (game) and controllers (clock, mouse)
    clock = ClockController(eventManager)
    mouse = InputController(eventManager)
    game = GoGame(eventManager, GAME_SIZE)
    pygameView= PygameView(eventManager, GAME_SIZE)
    
    clock.Start()

if __name__ == "__main__":
    main()