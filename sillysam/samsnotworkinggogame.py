import pdb

import os, sys
import pygame
from pygame.locals import *
from weakref import WeakKeyDictionary

if not pygame.font: print 'Warning, fonts disabled'
if not pygame.mixer: print 'Warning, sound disabled'

# CONSTANTS ---------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

DIRECTION_UP = 0
DIRECTION_DOWN = 1
DIRECTION_LEFT = 2
DIRECTION_RIGHT = 3

BOARD_SIZE = 9

# UTILITIES ---------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

def Debug(msg):
    print msg
    
def load_image(name, colorkey=None):
    fullname = os.path.join('data', name)
    try:
        image = pygame.image.load(fullname)
    except pygame.error, message:
        print 'Cannot load image:', name
        raise SystemExit, message
    image = image.convert()
    if colorkey is not None:
        if colorkey is -1:
            colorkey = image.get_at((0,0))
        image.set_colorkey(colorkey, RLEACCEL)
    return image, image.get_rect()

# EVENTS ------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------
        
class Event:
    """this is a superclass for any events that might be generated by an
    object and sent to the EventManager
    """
    def __init__(self):
        self.name = "Generic Event"
    
    def getName(self):
        return self.name
        
class TickEvent(Event):
    def __init__(self):
        self.name = "CPU Tick Event"
        
class QuitEvent(Event):
    def __init__(self):
        self.name = "Program Quit Event"
        
class BoardBuiltEvent(Event):
    def __init__(self, gameBoard):
        self.name = "Board Finished Building Event"
        self.board = gameBoard
        
    def getBoard(self):
        return self.board
        
class GameStartedEvent(Event):
    def __init__(self, game):
        self.name = "Game Started Event"
        self.game = game
    
    def getGame(self):
        return self.game
        
class PlayerMoveRequest(Event):
    def __init__(self, x, y, possibleLocations):
        self.name = "Player Move Request"
        self.x = x
        self.y = y
        
    def getX(self):
        return self.x
        
    def getY(self):
        return self.y
        
class CursorMoveRequest(Event):
    def __init__(self, direction):
        self.name = "Cursor Move Request"
        self.direction = direction
            
    def getDirection(self):
        return self.direction

class CursorMoveEvent(Event):
    def __init__(self, newPosition):
        self.name = "Cursor Move Event"
        self.position = newPosition
            
    def getPosition(self):
        return self.position

class CursorSelectRequest(Event):
    def __init__(self):
        self.name = "Cursor Select Request"
        
class PlayerMoveEvent(Event):
    def __init__(self, x, y, possibleLocations):
        self.name = "Player Move Event"
        self.points = possibleLocations
        
    def getPoints(self):
        return self.points
        
            
# CONTROLLERS -------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

class Controller:
    """this is a superclass for any controller that might be generated. 
    It ensures automatic registrations to the event manager
    """
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
    
class InputController(Controller):
    def Notify(self, event):
        if isinstance(event, TickEvent):
            for event in pygame.event.get():
                newEvent = None
                if event.type == KEYDOWN \
                    and event.key == K_ESCAPE:
                        newEvent = QuitEvent()
                elif event.type == KEYDOWN \
                    and event.key == K_UP:
                        newEvent = CursorMoveRequest(DIRECTION_UP)
                elif event.type == KEYDOWN \
                    and event.key == K_DOWN:
                        newEvent = CursorMoveRequest(DIRECTION_DOWN)
                elif event.type == KEYDOWN \
                    and event.key == K_LEFT:
                        newEvent = CursorMoveRequest(DIRECTION_LEFT)
                elif event.type == KEYDOWN \
                    and event.key == K_RIGHT:
                        newEvent = CursorMoveRequest(DIRECTION_RIGHT)
                elif event.type == KEYDOWN \
                    and event.key == K_RETURN:
                        newEvent = CursorSelectRequest()
                
                if newEvent:
                    self.eventManager.Post(newEvent)
 
class ClockController(Controller):
    def Start(self):
        self.keepGoing = True
        while self.keepGoing:
            event = TickEvent()
            self.eventManager.Post(event)
            
    def Notify(self, event):
        if isinstance(event, QuitEvent):
            self.keepGoing = False
            
# MANAGERS ----------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------
        
class EventManager:
    """this object is responsible for coordinating most communication
    between the Model, View, and Controller.
    """
    def __init__(self):
        self.listeners = WeakKeyDictionary()
        self.eventQueue = []
        
    def RegisterListener(self, listener):
        self.listeners[listener] = True

    def UnregisterListener(self, listener):
        if listener in self.listeners.keys():
            del self.listeners[listener]
        
    def Post(self, event):
        """Post a new event.  It will be broadcast to all listeners"""
        if not isinstance(event, TickEvent):
            Debug("     Message: " + event.name)
        for listener in self.listeners.keys():
            listener.Notify(event)
            

# VIEW --------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

class BoardGraphics(pygame.sprite.Sprite):
    def __init__(self, point, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        
        self.point = point
        
        bottom = right = max(range(BOARD_SIZE))
        top = left = min(range(BOARD_SIZE))
        
        if (self.point.x, self.point.y) in [(top, left),(top, right),(bottom, left),(bottom, right)]:
            self.image, self.imageRect = load_image('corner.png', -1)
            self.image = pygame.transform.smoothscale(self.image, (30,30))
            self.imageRect = (50+30*point.x, 50+30*point.y,50+30*(point.x+1), 50+30*(point.y+1))
        elif (point.x in [top, bottom]) or (point.y in [left, right]):
            self.image, self.imageRect = load_image('edge.png', -1)
            self.image = pygame.transform.smoothscale(self.image, (30,30))
            self.imageRect = (50+30*point.x, 50+30*point.y,50+30*(point.x+1), 50+30*(point.y+1))
        else:
            self.image, self.imageRect = load_image('default.png', -1)
            self.image = pygame.transform.smoothscale(self.image, (30,30))
            self.imageRect = (50+30*point.x, 50+30*point.y,50+30*(point.x+1), 50+30*(point.y+1))

class PieceGraphics(pygame.sprite.Sprite):
    def __init__(self, point, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        self.point = point
        self.update()
        
    def update(self):
        self.image, self.imageRect = self.point.getState()
        self.imageRect = (50+30*self.point.x, 50+30*self.point.y,50+30*(self.point.x+1), 50+30*(self.point.y+1))
        self.rect = pygame.Rect(self.imageRect)

class CursorGraphics(pygame.sprite.Sprite):
    def __init__(self, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        self.cursor, self.cursorRect = load_image('cursor.png', -1)
        self.image = pygame.transform.smoothscale(self.cursor, (30,30))
        colorkey = self.image.get_at((0,0))
        self.image.set_colorkey(colorkey, RLEACCEL)
        self.x, self.y = (0,0)
        self.update()
    
    def setPosition(self, x, y):
        self.x = x
        self.y = y
    
    def update(self):
        self.cursorRect = (50+30*self.x, 50+30*self.y,50+30*(self.x+1), 50+30*(self.y+1))
        self.rect = pygame.Rect(self.cursorRect)
        
class PygameView:
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        pygame.init()
        self.window = pygame.display.set_mode((30*BOARD_SIZE+100,30*BOARD_SIZE+100))
        pygame.display.set_caption('My Go Game')
        
        self.background = pygame.Surface(self.window.get_size())
        self.background.fill((0,0,0))
        
        font = pygame.font.Font(None, 30)
        text = "Press SPACE BAR to start"
        textImg = font.render( text, 1, (255,0,0))        
        self.background.blit( textImg, (0,0) )
        self.window.blit( self.background, (0,0) )
        pygame.display.update()
        
        self.backSprites = pygame.sprite.RenderUpdates()
        self.frontSprites = pygame.sprite.RenderUpdates()
        self.cursorSprite = pygame.sprite.RenderUpdates()
    
    def ShowBoard(self, board):
        self.background.fill( (0,0,0) )
        self.window.blit( self.background, (0,0) )
        pygame.display.flip()

        for row in board.points:
            for point in row:
                newSprite = BoardGraphics( point, self.backSprites )
                newSprite.rect = pygame.Rect(newSprite.imageRect)
                newSprite = None
        
        for row in board.points:
            for point in row:
                newSprite = PieceGraphics( point, self.frontSprites)
                newSprite = None
         
        newSprite = CursorGraphics(self.cursorSprite)
        newSprite = None
        
    def RefreshBoard(self, points):
        for row in points:
            for point in row:
                currentPiece = getPieceSprite(point)
                currentPiece.update()
                currentPiece = None
        
    def UpdateCursor(self, cursor, newPosition):
        cursorSprite = self.GetCursorSprite(cursor)
        cursorSprite.rect.topleft = newPosition
        
    def GetCursorSprite(self, point):
        for s in self.cursorSprite:
            return s
        return None

    def GetPieceSprite(self, point):
        for s in self.frontSprites:
            if hasattr(s, "point") and s.point == point:
                return s

    def GetPointSprite(self, point):
        for s in self.backSprites:
            if hasattr(s, "point") and s.point == point:
                return s
                
    def Notify(self, event):
        if isinstance(event, TickEvent):
            #Draw Everything
            self.backSprites.clear( self.window, self.background )
            self.frontSprites.clear( self.window, self.background )
            self.cursorSprite.clear( self.window, self.background )

            self.backSprites.update()
            self.frontSprites.update()
            self.cursorSprite.update()

            dirtyRects1 = self.backSprites.draw( self.window )
            dirtyRects2 = self.frontSprites.draw( self.window )
            dirtyRects3 = self.cursorSprite.draw( self.window )

            dirtyRects = dirtyRects1 + dirtyRects2 + dirtyRects3
            pygame.display.update( dirtyRects )

        elif isinstance(event, BoardBuiltEvent):
            self.ShowBoard(event.getBoard())

        elif isinstance(event, PlayerMoveEvent):            
            self.RefreshBoard(event.getPoints())
            
        elif isinstance(event, CursorMoveEvent):
            self.UpdateCursor(event.getPosition())

# GAME SPECIFIC -----------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------

class GoGame:
    
    STATE_PREPARING = 'Preparing'
    STATE_RUNNING =  'Running'
    STATE_PAUSED = 'Paused'
    
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        self.state = GoGame.STATE_PREPARING
        
        self.players =  [Player(eventManager, "white"), Player(eventManager, "black")]
        self.board = Board(eventManager)
        
    def Start(self):
        self.board.Build()
        self.state = GoGame.STATE_RUNNING
        
        self.eventManager.Post( GameStartedEvent(self) )
        
    def getStartPosition(self):
        return (0,0)
        
    def Notify(self, event):
        if isinstance(event, TickEvent):
            if self.state == GoGame.STATE_PREPARING:
                self.Start()

class Board:
    
    STATE_PREPARING = 0
    STATE_BUILT = 1
    
    def __init__(self, eventManager, size=9, goesFirst='black'):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        self.state = Board.STATE_PREPARING
        
        self.points = []
        self.size = size-1
        self.score =  {'black':0, 'white':0}
        self.currentColour = goesFirst
        
    def Build(self):
        boardNumbers = range(self.size)
        for x in boardNumbers:
            self.points.append([])
            for y in boardNumbers:
                self.points[x].append(Point(self.eventManager, x, y))
        
        for x in boardNumbers:
            for y in boardNumbers:
                if y != max(boardNumbers):
                    self.points[x][y].neighbors[DIRECTION_UP] = self.points[x][y+1]
                else:
                    self.points[x][y].neighbors[DIRECTION_UP] = None
                    
                if y != min(boardNumbers):    
                    self.points[x][y].neighbors[DIRECTION_DOWN] = self.points[x][y-1]
                else:
                    self.points[x][y].neighbors[DIRECTION_DOWN] = None                
                
                if x != max(boardNumbers):    
                    self.points[x][y].neighbors[DIRECTION_LEFT] = self.points[x+1][y]
                else:
                    self.points[x][y].neighbors[DIRECTION_LEFT] = None
                
                if x != min(boardNumbers):    
                    self.points[x][y].neighbors[DIRECTION_RIGHT] = self.points[x-1][y]
                else:
                    self.points[x][y].neighbors[DIRECTION_RIGHT] = None
        
        self.state = Board.STATE_BUILT
        
        self.eventManager.Post( BoardBuiltEvent(self) )
        
    def Notify(self, event):
        if isinstance(event, PlayerMoveRequest):
            x = event.getX()
            y = event.getY()
            move = self.point[x][y]
            if move.MovePossible() and (self.Kills(move) or self.IsAlive(move)):                
                move.setState(self.currentColour)
                self.SwapColour()
                newEvent = PlayerMoveEvent(self.points)
                self.eventManager.Post(newEvent)
                
    def SwapColour(self):
        if self.currentColour == 'black':
            self.currentColour = 'white'
        elif self.currentColour == 'white':
            self.currentColour = 'black'
        else:
            raise NoColourError
    
    def IsAlive(self, move):
        if len(CheckMove(self, move)) > 0:
            return False
        else:
            return True
        
    def Kills(self, move):
        neighbors = move.getNeighbors()
        move.setState(self.currentColour)
        willDie = set()
        for neighbor in neighbors:
            if (not neighbor.isEmpty()) and (neighbor.getState() != move.getState()):
                willDie.add(CheckMove(neighbor))
        
        if len(willDie) > 0:
            for point in willDie:
                point.setState(None)
                self.score[self.currentColour]+=1
            return True
        else:
            move.setState(None)
            return False
    
    def CheckMove(self, move, checkedGroup = set(), uncheckedGroup= set()):
        if move.hasLiberties():
            return set()
        else:
            checkedGroup.add(move)
            newNeighbors = set(move.getNeighbors()).difference(checkedGroup)
            uncheckedGroup.add(newNeighbors)
            if len(uncheckedGroup) > 0:
                newMove = uncheckedGroup.pop()
                return CheckMove(newMove, checkedGroup, uncheckedGroup)        
            else:
                return checkedGroup
                
    def playMove(self, x,y):
        CheckMove(self.points[x][y])

class Point:
    def __init__(self, eventManager, x, y):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        self.state = None
        self.friendlyNeighbors = None
        
        self.blankImage, self.blankRect = load_image('emptypiece.png', -1)
        self.blankImage = pygame.transform.smoothscale(self.blankImage, (30,30))
        colorkey = self.blankImage.get_at((0,0))
        self.blankImage.set_colorkey(colorkey, RLEACCEL)
        
        self.whiteImage, self.whiteRect = load_image('whitepiece.png', -1)
        self.whiteImage = pygame.transform.smoothscale(self.whiteImage, (30,30))
        colorkey = self.whiteImage.get_at((0,0))
        self.whiteImage.set_colorkey(colorkey, RLEACCEL)
        
        self.blackImage, self.blackRect = load_image('blackpiece.png', -1)
        self.blackImage = pygame.transform.smoothscale(self.blackImage, (30,30))
        colorkey = self.blackImage.get_at((0,0))
        self.blankImage.set_colorkey(colorkey, RLEACCEL)
        
        self.x = x
        self.y = y
        
        self.neighbors = range(4)
        self.neighbors[DIRECTION_UP] = None
        self.neighbors[DIRECTION_DOWN] = None
        self.neighbors[DIRECTION_LEFT] = None
        self.neighbors[DIRECTION_RIGHT] = None
        
    def MovePossible(self):
        if self.state == None:
            return True
        else:
            return False
        
    def setState(self, state):
        self.state = state        
        
    def getState(self):
        if self.state == 'white':
            return self.whiteImage, self.whiteRect
        elif self.state == 'black':
            return self.blackImage, self.blackRect
        elif self.state == None:
            return self.blankImage, self.blankRect
        else:
            raise Error
        
    def isEmpty(self):
        if self.state == None:
            return True
        else:
            return False
            
    def isWhite(self):
        if self.state == 'white':
            return True
        else:
            return False
            
    def isBlack(self):
        if self.state == 'black':
            return True
        else:
            return False
    
    def getNeighbors(self):
        return self.neighbors
        
    def hasLiberties(self):
        for neighbor in self.neighbors:            
            if neighbor.isEmpty():
                return True
        
        return False
        
    def Notify(self, event):
        pass
    
class Cursor:
    def __init__(self):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        
        x,y = (0,0)
        self.x = x
        self.y = y
        
    def updatePosition(self, direction):
        if ((direction == DIRECTION_UP) and (self.x != self.size)):
            self.x += 1
        elif ((direction == DIRECTION_DOWN) and (self.x != 0)):
            self.x -= 1
        elif ((direction == DIRECTION_RIGHT) and (self.y != self.size)):
            self.y += 1
        elif ((direction == DIRECTION_LEFT) and (self.y != 0)):
            self.y -= 1
        else:
            raise directionError
        
    def Notify(self, event):
        if isinstance(event, CursorSelectRequest):
            newEvent = playerMoveRequest(self.x, self.y)
            self.eventManager.Post(newEvent)
        elif isinstance(event, CursorMoveRequest):
            updatePosition(event.getDirection())
            newEvent = playerMoveEvent(self.x, self.y)
            self.eventManager.Post(newEvent)

class Player:
    def __init__(self, eventManager, colour, start_score = 0):
        self.eventManager = eventManager
        self.eventManager.RegisterListener(self)
        self.colour = colour
        self.score = start_score
        
    def __str__(self):
        return "Player: " + self.colour
    
    def Notify(self, event):
        pass
        
# MAIN --------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------              
    
def main():
    eventManager = EventManager()
    
    mouse = InputController(eventManager)
    clock = ClockController(eventManager)
    game = GoGame(eventManager)
    pygameView= PygameView(eventManager)
    
    clock.Start()

if __name__ == "__main__":
    main()
